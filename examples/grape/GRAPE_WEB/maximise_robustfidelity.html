
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
      <title>Filename : maximise_robustfidelity</title>
      <meta name="generator" content="MATLAB 7.14">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2014-03-05">
      <meta name="DC.source" content="maximise_robustfidelity.m">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <link rel="stylesheet" type="text/css" href="css/screen.css" media="screen" />
  </head>
  
  
<body>
    <ul id=menu>
      <li><a href="flowchart.html">Flow Chart</a>
      <li><a href="tools/tools.html">Tools</a>
      <li><a href="faq/faq.html">F. A. Q.</a>
      <li><a href="../index.html">NMR-QIP Page</a>
    </ul>
    <div class="content"><h1>Filename : maximise_robustfidelity</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li></ul></div><h2>Description<a name="1"></a></h2><p>This program calculates the gradient which inturn helps in calculation of new set of controls. Check the GRAPE paper by N Khaneja for specifics. gra.af are gradients, which are supplied to find_lambda_bconst for calculating conjugate gradients. check <a href="find_lambda_bconst.html">find_lambda_bconst</a> for more details.</p><pre class="codeinput"><span class="keyword">function</span> [epsi_new u skipping_calc_fid U_s X_s] = maximise_robustfidelity(P,X,u,epsi,iter,Fid_first)
</pre><pre class="codeinput"><span class="keyword">global</span> gra

t=(gra.T/gra.N);
U_t=gra.U_target;
Hrf=gra.Hrf;
epsi_range=[0 epsi 2*epsi];
spinlist = gra.spinlist;
</pre><p><a name="7"></a>calculation of gradient (see GRAPE paper for specifics)</p><p><img src="Images/maximise_robustfidelity_eq00332.png" alt="$gradient = -2\mathrm{real}(\langle P_j \vert i \Delta t H_k X_j \rangle\langle X_j \vert P_j \rangle)$"></p><p>which translates to following in our notations scheme,</p><p><img src="Images/maximise_robustfidelity_eq42609.png" alt="$gra.af_j = -2\mathrm{real}(\mathrm{trace}(X(:,:,j+1) U_t^{\dagger} P(:,:,j) i \Delta t H_k) (X(:,:,j+1)^{\dagger} U_t))$"></p><pre class="codeinput">su=zeros(gra.N,gra.m);
<span class="keyword">for</span> l=1:length(gra.rfINHrange)
    trxjpj = trace(X(:,:,gra.N+1,l)'*U_t);
    <span class="keyword">for</span> j=1:gra.N
        XjUtPj = X(:,:,j+1,l)*U_t'*P(:,:,j,l);
        <span class="keyword">for</span> k=1:gra.m
            gra.af(j,k,l) = -2*real(trace(XjUtPj*1i*t*Hrf{1,k})*trxjpj)/2^(2*gra.nspins);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    su=su+gra.rfINHiwt(l)*gra.af(:,:,l);
    gra.af=su;
<span class="keyword">end</span>
</pre><p>Calculation of conjugate gradients</p><pre class="codeinput">lambda=find_lambda_bconst(iter);
</pre><p>The conjugate gradient is evaluate for <img src="Images/maximise_robustfidelity_eq97780.png" alt="$\epsilon$"> = <img src="Images/maximise_robustfidelity_eq97780.png" alt="$\epsilon$"> and <img src="Images/maximise_robustfidelity_eq25488.png" alt="$2\epsilon$"> and fidelity is saved in fide. check <a href="quadratic_fit.html">quadratic_fit</a> for more details</p><pre class="codeinput">U=zeros(2^gra.nspins,2^gra.nspins,gra.N);
fide(1)=Fid_first;
<span class="keyword">for</span> d=2:length(epsi_range)
    u_new = u + epsi_range(d)*lambda;
    u_new=penalizecontrols(u_new);
    fid=zeros(1,length(gra.rfINHrange));
    <span class="keyword">for</span> k=1:length(gra.rfINHrange)
        X(:,:,1)=eye(2^gra.nspins);
        <span class="keyword">for</span> j=1:gra.N
            sum_hamil=zeros(2^gra.nspins);
            <span class="keyword">for</span> n=1:length(spinlist)
                A=gra.rfINHrange(k)*sqrt(u_new(j,n)^2+u_new(j,n+length(spinlist))^2);
                phi=atan2(u_new(j,n+length(spinlist)),u_new(j,n));
                sum_hamil = sum_hamil+A*cos(phi)*(gra.Hrf{1,n}) + A*sin(phi)*(gra.Hrf{1,n+length(spinlist)});
            <span class="keyword">end</span>
            U(:,:,j,k) = expm(-1i*(gra.del_t)*(gra.Hint + sum_hamil));
            X(:,:,j+1,k)=U(:,:,j,k)*X(:,:,j,k);
        <span class="keyword">end</span>
        fid(k)= (abs(trace(gra.U_target'*X(:,:,gra.N+1,k)))/2^(gra.nspins))^2;
    <span class="keyword">end</span>
    eval([<span class="string">'Usave'</span> num2str(d) <span class="string">'=U;'</span>]);
    eval([<span class="string">'Xsave'</span> num2str(d) <span class="string">'=X;'</span>]);
    fide(d) = fid*gra.rfINHiwt;
<span class="keyword">end</span>
</pre>
<a name="8"></a>
<p>Doing a quadratic fit, check the program <a href="quadratic_fit.html">quadratic_fit</a> for more details</p><pre class="codeinput">multi_fac=quadratic_fit(fide);
gra.mfa(iter)=multi_fac;
epsi_new=multi_fac*epsi;
u=u+epsi_new*lambda;

<span class="comment">% The new set of controls are penalized</span>
u=penalizecontrols(u);

<a name="9"></a>
<span class="comment">% checking if the new $\epsilon$ is either 1 or 2. If yes, then send a flag</span>
<span class="comment">% using skipping_calc_fid to the rungrape for skipping the matrix</span>
<span class="comment">% exponentiation.</span>
<span class="keyword">if</span>(multi_fac==2)
    skipping_calc_fid = 1;
    U_s=Usave3;
    X_s=Xsave3;
<span class="keyword">elseif</span>(multi_fac==1)
    skipping_calc_fid = 1;
    U_s=Usave2;
    X_s=Xsave2;
<span class="keyword">else</span>
    skipping_calc_fid = 0;
    U_s=[];
    X_s=[];
<span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% Filename : maximise_robustfidelity

%% Description
% This program calculates the gradient which inturn helps in calculation of
% new set of controls. Check the GRAPE paper by N Khaneja for specifics.
% gra.af are gradients, which are supplied to find_lambda_bconst for
% calculating conjugate gradients. check find_lambda_bconst for more
% details.

function [epsi_new u skipping_calc_fid U_s X_s] = maximise_robustfidelity(P,X,u,epsi,iter,Fid_first)
global gra

t=(gra.T/gra.N);
U_t=gra.U_target;
Hrf=gra.Hrf;
epsi_range=[0 epsi 2*epsi];
spinlist = gra.spinlist;

%%
%
% calculation of gradient (see GRAPE paper for specifics)
% 
% $gradient = -2\mathrm{real}(\langle P_j \vert i \Delta t
% H_k X_j \rangle\langle X_j \vert P_j \rangle)$
%
% which translates to following in our notations scheme,
%
% $gra.af_j = -2\mathrm{real}(\mathrm{trace}(X(:,:,j+1) U_t^{\dagger} P(:,:,j) i \Delta t H_k) (X(:,:,j+1)^{\dagger} U_t))$
%
su=zeros(gra.N,gra.m);
for l=1:length(gra.rfINHrange)
    trxjpj = trace(X(:,:,gra.N+1,l)'*U_t);
    for j=1:gra.N
        XjUtPj = X(:,:,j+1,l)*U_t'*P(:,:,j,l);
        for k=1:gra.m
            gra.af(j,k,l) = -2*real(trace(XjUtPj*1i*t*Hrf{1,k})*trxjpj)/2^(2*gra.nspins);
        end
    end
    su=su+gra.rfINHiwt(l)*gra.af(:,:,l);
    gra.af=su;
end

%%
% Calculation of conjugate gradients
lambda=find_lambda_bconst(iter);

%%
% The conjugate gradient is evaluate for $\epsilon$ = $\epsilon$ and
% $2\epsilon$ and fidelity is saved in fide. check quadratic_fit for more
% details
U=zeros(2^gra.nspins,2^gra.nspins,gra.N);
fide(1)=Fid_first;
for d=2:length(epsi_range)
    u_new = u + epsi_range(d)*lambda;
    u_new=penalizecontrols(u_new);
    fid=zeros(1,length(gra.rfINHrange));
    for k=1:length(gra.rfINHrange)
        X(:,:,1)=eye(2^gra.nspins);
        for j=1:gra.N
            sum_hamil=zeros(2^gra.nspins);
            for n=1:length(spinlist)
                A=gra.rfINHrange(k)*sqrt(u_new(j,n)^2+u_new(j,n+length(spinlist))^2);
                phi=atan2(u_new(j,n+length(spinlist)),u_new(j,n));
                sum_hamil = sum_hamil+A*cos(phi)*(gra.Hrf{1,n}) + A*sin(phi)*(gra.Hrf{1,n+length(spinlist)});
            end
            U(:,:,j,k) = expm(-1i*(gra.del_t)*(gra.Hint + sum_hamil));
            X(:,:,j+1,k)=U(:,:,j,k)*X(:,:,j,k);
        end
        fid(k)= (abs(trace(gra.U_target'*X(:,:,gra.N+1,k)))/2^(gra.nspins))^2;
    end
    eval(['Usave' num2str(d) '=U;']);
    eval(['Xsave' num2str(d) '=X;']);
    fide(d) = fid*gra.rfINHiwt;
end

%%
% Doing a quadratic fit, check the program for more details
multi_fac=quadratic_fit(fide);
gra.mfa(iter)=multi_fac;
epsi_new=multi_fac*epsi;
u=u+epsi_new*lambda;

% The new set of controls are penalized
u=penalizecontrols(u);

% checking if the new $\epsilon$ is either 1 or 2. If yes, then send a flag
% using skipping_calc_fid to the rungrape for skipping the matrix
% exponentiation.
if(multi_fac==2)
    skipping_calc_fid = 1;
    U_s=Usave3;
    X_s=Xsave3;
elseif(multi_fac==1)
    skipping_calc_fid = 1;
    U_s=Usave2;
    X_s=Xsave2;
else
    skipping_calc_fid = 0;
    U_s=[];
    X_s=[];
end


##### SOURCE END #####
--></body></html>