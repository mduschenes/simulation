
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Filename : testRobust</title>
      <meta name="generator" content="MATLAB 7.14">
      <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
      <meta name="DC.date" content="2014-03-05">
      <meta name="DC.source" content="testRobust.m">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen" />
  </head>
  
<body>
    <ul id=menu>
      <li><a href="../flowchart.html">Flow Chart</a>
      <li><a href="../tools/tools.html">Tools</a>
      <li><a href="../faq/faq.html">F. A. Q.</a>
      <li><a href="../../index.html">NMR-QIP Page</a>
    </ul>
    <div class="content"><h1>FileName : testRobust</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Command</a></li><li><a href="#3">Example Output</a></li></ul></div><h2>Description<a name="1"></a></h2><p>Plots the variation of fidelity with RF inhomeginity.</p><h2>Command<a name="2"></a></h2><p><b>testRobust(GRinfo,inc_range,range,state)</b></p><p><b>GRinfo</b> : Variable in which all the information of grape pulse is stored.</p><p><b>inc_range</b> : the increment value in spanning the range, default is 0.01.</p><p><b>range</b> : min and mac value (range) of the RF inhomogenity, for example [0.8 1.2], default value is the RF inhomogenity range in pulse generation.</p><p><b>state</b> : 'y' if the pulse is for state to state transfer, default is 'n'.</p><h2>Example Output<a name="3"></a></h2><p>Shown below is an example plot.</p><p><img vspace="5" hspace="5" src="../tools/img/sample_testRobust.jpg" alt=""> </p><pre class="codeinput"><span class="keyword">function</span> testRobust(GRinfo,inc_range,rang,state)
<span class="keyword">global</span> gra
gra=GRinfo;

<span class="comment">%---------------Declaring Defaults------------</span>
<span class="keyword">if</span> (nargin &lt; 2 || isempty(inc_range)); inc_range=.01; <span class="keyword">end</span>
<span class="keyword">if</span> (nargin &lt; 3 || isempty(rang)); range=min(gra.rfINHrange):inc_range:max(gra.rfINHrange);
<span class="keyword">else</span>
    range=min(rang):inc_range:max(rang);
<span class="keyword">end</span>
<span class="keyword">if</span> (nargin &lt; 4 || isempty(state)); state=<span class="string">'n'</span>; <span class="keyword">end</span>

<span class="comment">%-----------------------------------------------------------</span>

X1(:,:,1)=eye(2^gra.nspins);
U1=zeros(2^gra.nspins,2^gra.nspins,gra.N);
A=zeros(1,gra.N);
phi=zeros(1,gra.N);
spinlist = gra.spinlist;
u=gra.u;

<span class="keyword">if</span> state == <span class="string">'y'</span>
    gra.Ud = expm(1i*gra.Hint*gra.initdelay);
    gra.RHO_init = gra.Ud*gra.RHO_init*gra.Ud';
<span class="keyword">else</span>
    gra.U_target=expm(1i*gra.initdelay*gra.Hint)*gra.Utarg*expm(1i*gra.initdelay*gra.Hint);

<span class="keyword">end</span>

<span class="keyword">for</span> k=1:length(range)
    <span class="keyword">for</span> j=1:gra.N
        sum_hamil=zeros(2^gra.nspins);
        <span class="keyword">for</span> n=1:length(spinlist)
            A(j,n)=range(k)*sqrt(u(j,n)^2+u(j,n+length(spinlist))^2);
            phi(j,n)=atan2(u(j,n+length(spinlist)),u(j,n));
            sum_hamil = sum_hamil+A(j,n)*cos(phi(j,n))*(gra.Hrf{1,n}) + A(j,n)*sin(phi(j,n))*(gra.Hrf{1,n+length(spinlist)});
        <span class="keyword">end</span>
        U1(:,:,j) = expm(-1i*(gra.T/gra.N)*(gra.Hint + sum_hamil));
        X1(:,:,j+1)=U1(:,:,j)*X1(:,:,j);
    <span class="keyword">end</span>
    <span class="keyword">if</span> state==<span class="string">'y'</span>
        fidelity(k) = (abs(trace(gra.RHOtarg'*X1(:,:,gra.N+1)*gra.RHO_init*X1(:,:,gra.N+1)')));
    <span class="keyword">else</span>
        fidelity(k) = (abs(trace(gra.U_target'*X1(:,:,gra.N+1)))/2^(gra.nspins))^2;
    <span class="keyword">end</span>
<span class="keyword">end</span>

avgfil=100*mean(fidelity);
fprintf(<span class="string">'Average Fidelity : %2.6f\n'</span>,avgfil)

<span class="comment">%--------PLOT-----------------</span>
figure
plot(range,fidelity)
xlabel(<span class="string">'RF Inhomogenity'</span>); ylabel(<span class="string">'Fidelity'</span>);
title(<span class="string">'Robustness Plot'</span>)
title([<span class="string">'Robustness Plot || Avg. Fidelity:'</span>,num2str(avgfil),<span class="string">'%'</span>]);
grid <span class="string">on</span>
axis <span class="string">tight</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% FileName : testRobust

%% Description
% Plots the variation of fidelity with RF inhomeginity.

%% Command
% *testRobust(GRinfo,inc_range,range,state)*
%
% *GRinfo* : Variable in which all the information of grape pulse is stored.
% 
% *inc_range* : the increment value in spanning the range, default is 0.01.
% 
% *range* : min and mac value (range) of the RF inhomogenity, for
% example [0.8 1.2], default value is the RF inhomogenity range in pulse
% generation.
% 
% *state* : 'y' if the pulse is for state to state transfer, default is
% 'n'.

%% Example Output
% Shown below is an example plot. 
%
% <<sample_testRobust.jpg>>


function testRobust(GRinfo,inc_range,rang,state)

if nargin<1
    disp('  ')
    disp('  ')
    disp('      testRobust(GRinfo,inc_range,Range)')
    disp('      Calculate the Robustness of the simulated gate under RF inhomogenity')
    disp('              ')
    disp('        inc_range - the increament value in spanning the range')
    disp('                     {default:0.01}')
    disp('            Range - range of RF inhomogenity e.g [.80 1.2]')
    disp('                    {default : takes the range for which pulse is generated}')
    disp('  ')
    disp('      SIMPLEST INPUT : testRobust(GRinfo,[],[])')
    disp('  ')
    disp('  ')
    disp('   It is unnecessary to provide all the inputs.  Empty inputs indicate')
    disp('   indicate default selections.')
    disp('  ')
    disp('   (Hemant Katiyar, 2012)')
    return
end

global gra
gra=GRinfo;

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Declaring DefaultsREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
if (nargin < 2 || isempty(inc_range)); inc_range=.01; end
if (nargin < 3 || isempty(rang)); range=min(gra.rfINHrange):inc_range:max(gra.rfINHrange);
else
    range=min(rang):inc_range:max(rang);
end
if (nargin < 4 || isempty(state)); state='n'; end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

X1(:,:,1)=eye(2^gra.nspins);
U1=zeros(2^gra.nspins,2^gra.nspins,gra.N);
A=zeros(1,gra.N);
phi=zeros(1,gra.N);
spinlist = gra.spinlist;
u=gra.u;

if state == 'y'
    gra.Ud = expm(1i*gra.Hint*gra.initdelay);
    gra.RHO_init = gra.Ud*gra.RHO_init*gra.Ud'; 
else
    gra.U_target=expm(1i*gra.initdelay*gra.Hint)*gra.Utarg*expm(1i*gra.initdelay*gra.Hint);

end

for k=1:length(range)
    for j=1:gra.N
        sum_hamil=zeros(2^gra.nspins);
        for n=1:length(spinlist)
            A(j,n)=range(k)*sqrt(u(j,n)^2+u(j,n+length(spinlist))^2);
            phi(j,n)=atan2(u(j,n+length(spinlist)),u(j,n));
            sum_hamil = sum_hamil+A(j,n)*cos(phi(j,n))*(gra.Hrf{1,n}) + A(j,n)*sin(phi(j,n))*(gra.Hrf{1,n+length(spinlist)});
        end  
        U1(:,:,j) = expm(-1i*(gra.T/gra.N)*(gra.Hint + sum_hamil));
        X1(:,:,j+1)=U1(:,:,j)*X1(:,:,j);
    end
    if state=='y'
        fidelity(k) = (abs(trace(gra.RHOtarg'*X1(:,:,gra.N+1)*gra.RHO_init*X1(:,:,gra.N+1)')));
    else
        fidelity(k) = (abs(trace(gra.U_target'*X1(:,:,gra.N+1)))/2^(gra.nspins))^2;
    end
end

avgfil=100*mean(fidelity);
fprintf('Average Fidelity : %2.6f\n',avgfil)

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHPLOTREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
figure
plot(range,fidelity)
xlabel('RF Inhomogenity'); ylabel('Fidelity');
title('Robustness Plot')
title(['Robustness Plot || Avg. Fidelity:',num2str(avgfil),'%']);
grid on
axis tight

##### SOURCE END #####
--></body></html>