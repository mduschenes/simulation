#!/usr/bin/env python

# Import python modules
import sys,os,datetime,itertools,json,subprocess
import glob as globber
from shutil import copy2 as cp
import numpy as np

CALL = 0

ARGS = {
	'pc':{
		'args': lambda args: ['./%s'%(args[0]),*args[1:]],
		},
	'lsf':{
		'args': lambda args: ['bsub','<',*args[:1]],
		},	
	'null': {
		'args': lambda args: [],
		},
	}

SETTINGS = {
}


# glob path
def glob(paths,**kwargs):
	return [p for path in paths for p in globber.glob(os.path.expanduser(path),**kwargs)]

# Join paths
def join(*paths,file=None,ext=None):
	isfile = file is not None
	isext = ext is not None and isfile and not file.endswith(ext)
	paths = list(paths)
	if isfile:	
		if isext:
			file = '%s.%s'%(file,ext)
		file_basename = os.path.basename(file)	
		if len(paths)>0:		
			file = file_basename		
		paths.append(file)
	path = os.path.join(*paths)
	if isfile:
		return path,file_basename
	else:
		return path

# Load json data
def load(path,obj):
	with open(path,'r') as fobj:
		try:
			return json.load(fobj)
		except Exception as e:
			raise e
	return

# Dump json data
def dump(path,obj):
	mkdir(path)
	with open(path,'w') as fobj:
		try:
			json.dump(obj,fobj)
		except Exception as e:
			pass
	return	

# Safely make directory
def mkdir(path):
	if os.path.isfile(path) or len(os.path.splitext(path)[-1])>0:
		directory = os.path.dirname(path)
	else:
		directory = path
	if directory not in [''] and not os.path.exists(directory):
		os.makedirs(directory)
	return


# Copy file
def copy(sources,destination,name=None,recursive=False,exceptions=[]):
	if recursive:
		sources = ['%s%s%s'%(source,'' if source.endswith(os.path.sep)  else os.path.sep,'**')
					for source in sources]
	exceptions = glob(exceptions)

	mkdir(destination)
	if os.path.isdir(destination) and name is not None:
		destination,name = join(destination,file=name)
	for source in glob(sources):
		if source not in exceptions:
			cp(source,destination)
	return

# Class to safely change directories
class cd(object):
	def .init.(self,path):
		self.path = path
	def .enter.(self):
		self.cwd = os.getcwd()
		os.chdir(self.path)
	def .exit.(self,etype, value, traceback):
		os.chdir(self.cwd)



# Submit call to command line
def submit(*args,directory='.',call=CALL):
	with cd(directory):
		if call:
			# try:
				args=' '.join(args)
				stdout = os.system(args)
			# except:
			# 	pass
		else:
			print(*args)
	return

# Get all combinations of dictionary of lists
def permute(dictionary,_groups=None,_keep_order=False):

	def indexer(keys,values,_groups):
		if _groups is not None:
			inds = [[keys.index(k) for k in g] for g in _groups]
		else:
			inds = []
			_groups = []
		N = len(_groups)
		_groups.extend([[k] for k in keys if all([k not in g for g in _groups])])
		inds.extend([[keys.index(k) for k in g] for g in _groups[N:]])
		values = [[values[j] for j in i ] for i in inds]
		return _groups,values

	def zipper(keys,values): 
		return [dict(zip(keys,v)) for v in zip(*values)]

	def unzipper(dictionary):
		keys, values = zip(*dictionary.items())	
		return keys,values

	def permuter(dictionaries): 
		return [{k:d[k] for d in dicts for k in d} for dicts in itertools.product(*dictionaries)]

	if dictionary in [None,{}]:
		return [{}]

	keys,values = unzipper(dictionary)
	
	_keys = keys
	
	keys,values = indexer(keys,values,_groups)

	dictionaries = [zipper(k,v) for k,v in zip(keys,values)]

	dictionaries = permuter(dictionaries)

	if _keep_order:
		for i,d in enumerate(dictionaries):
			dictionaries[i] = {k: dictionaries[i][k] for k in _keys}    
	return dictionaries

	


def main(cwd,src,jobs,paths,arguments=None,settings={},default=None,**kwargs):
	jobs = glob(jobs)
	paths = glob(paths)
	if len(jobs) == 1:
		jobs = [jobs[0] for path in paths]

	arguments = [] if arguments is None else arguments

	directory = datetime.datetime.today().strftime("%Y_%m_%d-%H_%M_%S")
	iteration = -1
	default

	for job,path in zip(jobs,paths):
		
		_settings = {}
		_settings = load(path,default=_settings)

		folder = join(cwd,directory)
		_file,file = join(folder,file=path,ext='all')
		dump(_file,{**settings,
				**{k:[_settings[k]] 
					for k in _settings 
					if k not in settings}})

		for settings_ in permute(settings):
			iteration += 1

			_settings.update(settings_)
	
			folder = join(cwd,directory,str(iteration))
			file,_file = join(folder,file=default if default is not None else path)
			job,_job = join(file=job)

			copy([src],folder,recursive=True,exceptions=['*.*'.join([*f.split('.')[:-1],'']) for f in [path,job]])
			copy([job],folder)
			dump(file,_settings)

			if callable(arguments):
				args = arguments([_job,_file])
			else:
				args = arguments[:]
				args.extend([_job,_file])

			submit(*args,directory=folder)

	return





if __name__ == "__main__":
	args = sys.argv[1:]
	if len(args) >= 5:
		settings = SETTINGS
		arguments = ARGS.get(args[0],ARGS['null'])['args']
		cwd = args[1]
		src = args[2]
		default = args[3]
		jobs = args[4:5]
		paths = args[5:]
		main(cwd,src,jobs,paths,arguments,settings,default)